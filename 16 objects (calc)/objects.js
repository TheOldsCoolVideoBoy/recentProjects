/* 
Объект это тип переменной который не является примитивом, то есть в отличии от чисел и строк, которые хранят лишь одно определённое значение, объект может хранить в себе множество разных переменных. 
к примеру синтаксис выглядит вот так:
*/

let object = {
    key/*"ключ" или же "имя", "индентификатор"*/: "value" /*"свойство" или же "значение"*/,/*отделяемые от других значений запятыми*/  

    /*например*/
    country: "Russia",
    myAge: 21,
    bodyTemperature: 36.6,
    isAlive: true,
    /*!!!после каждого значения нужно ставить запятую!!!*/
    /*не знаю зачем, думаю для расширения кода, что бы просто не путаться*/

    /*UPD. js learn гласит: 
    "Это называется «висячая запятая». Такой подход упрощает добавление, удаление и перемещение свойств, так как все строки объекта становятся одинаковыми."*/

};//не забываем точку с запятой в конце объекта

/*
Но объекты в отличии от примитивов имеют свою систему взаимодействия в программе

Например для того чтобы обратиться к значению любого ключа объекта, необходимо произвести запись имени обекта к ключу обекта через точку:  
*/
console.log(`Country where I live is - ${object.country}`);
console.log(`I am ${object.myAge} years old`);

/*
добавление имени в объект осуществляется как "немая" инициализация
т.е. чтобы добавить любую пару ключ:значение, нужно всего лишь вызвать желаемый идентификатор и присвоить ему значение:
*/
object.dateOfBirth = "27.06.2001";

console.log(`My date of birth is - ${object.dateOfBirth}`);

/*
Для удаления любого свойства из обекта используется специальный оператор "delete":
*/
delete object.bodyTemperature;

console.log(object.bodyTemperature);//undefined

/*
ВАЖНО!
Объект объявленный как константа, всё ещё может быть изменён!
почему?
потому что константой становиться целое взаимодействие с самим объектом, а не его свойства, т.е
*/
const capital = {
    Russia: "Moscow",
    USA: "Washington",
};

console.log(`Capital of the Russia is ${capital.Russia} and capital of the USA is ${capital.USA}`);//Capital of the Russia is Moscow and capital of the USA is Washington

//capital = {Uzbekistan: "Tashkent"};
//код выше выведет ошибку TypeError о том что объект является неизменяемым
//НО!

capital.Russia = "Tashkent";
console.log(`Capital of the Russia is ${capital.Russia} and capital of the USA is ${capital.USA}`);//Capital of the Russia is Tashkent and capital of the USA is Washington
//изменит свойство Russia, потому что const принадлежит объекту, а не свойствам внутри него.

//способы сделать константами свойства объекта рассмотрятся в главе "Флаги и дескрипторы свойств"


/*
Если нам нужено имя свойства в объекте, который состоит из нескольких слов, нам необходимо заключить его имя в кавычки:
*/

let neighbour = {
    "Street of living": "Lenina St.",
    "Neighbours name": "Ivan Ivanov",
    "Mop floor": true,
};

/*
Для того чтобы вызвать имя свойства из нескольких слов, нужно заключить его в квадратные скобки вместе с кавычками (Точка не требуется), иначе js считает только первое слово имени свойства:
*/
console.log(`My neighbour's name is ${neighbour["Neighbours name"]}`);

/*
с помощью такого способа можно также добавить и удалить имя свойства в объекте:
*/
neighbour["Years old"] = 25;

console.log(`My neighbour's name is ${neighbour["Neighbours name"]}, and he is ${neighbour["Years old"]} years old`);

delete neighbour["Mop floor"];

console.log(neighbour["Mop floor"]);//undefined

/*
при таком взаимодействии можно использовать любые кавычки:
*/
console.log(`My neighbour's name is ${neighbour["Neighbours name"]}, he is ${neighbour['Years old']} years old and he leaves on ${neighbour[`Street of living`]}`);

/*
крч мы можем запихнуть имя свойства в переменную и сделать вот так:
*/

//объект для примера
let pets = {
    cat: "animal",
};

//создаём переменную с желаемым именем свойства
let animal = "gold fish";

//и теперь мы можем при помощи квадратных скобок использовать эту переменную и задать свойство в объект.
pets[animal] = "fish";//тоже самое что и pets["gold fish"] = "fish";

/* тут должен быть пример с вводом, но потоки в node js это другая тема*/
//но можно представить что мы вводим числа и поэтому...

/*создадим объект и переменную "в которую типа мы ввели значение с клавиатуры"*/
let vegetable = "tomato";//имитируем ввод

let buyVegetable = {
    [vegetable]: 5,
};

console.log(`I'm gonna buy ${buyVegetable./*-->*/tomato/*<--*/} tomato`);

//теперь если названия совпадают, интерпритатор выведет свойство имени
//если нет, то undefined (минус20 минут моей жизни, а нужно лишь внимательнее читать код)

//ещё один пример
let fruit = "apple";//имитируем ввод
let bag = {};

bag[fruit] = 5;
console.log(bag.apple);

//можно использовать более сложные выражения
let bear = "panda";//имитируем ввод
let zoo = {
    [bear + 'LiveInZoo']: 2,
};
console.log(zoo.pandaLiveInZoo);

/*
иногда нужно чтобы имена свойств совпадали со значениями свойств
например:
*/
function makeUser(name, age) {
    return {
        name: name,
        age: age,
        //и тд...
    };
}

let user = makeUser("John", 30);
console.log(user.name);// John

/*
существует короткая запись таких свойств
вместо name:name можно записать просто name
*/

function makeClient(name, age) {
    return{
        name,
        age,
        //...
    };
}

let client = makeClient("Guest", 20);
console.log(client.name);// John

/*
любое имя свойства приводится к строке, поэтому нет ограничений на имена свойств:
*/
let obj = {
    for: 1,
    let: 2,
    fuction: 3,
    return: 4,
    while: 5,
};

console.log(obj.for + obj.let + obj.fuction + obj.return + obj.while);// 15

/* и цифры тоже */

let cursedObject = {
    0: "Работает",
};

console.log(cursedObject["0"]);// работает
console.log(cursedObject[0]);// работает

/*
существует оператор in который проверяет существует ли то или иное свойство в объекте возвращая true/false

конечно всегда можно сравнить свойство с undefined
но что вы будете делать если свойство равно undefined?
*/

let birds = {
    platypus:undefined,
    cockorel: 23,
    pigeon: 100,
};
console.log(birds.platypus === undefined, birds.dog === undefined)
//true true - мы предпологаем что при проверке на undefined результат покажет, существует свойство или нет, как мы видим, это не лучший способ, ведь утконос присутсвует как свойство
console.log("platypus" in birds, "pigeon" in birds);
// true true - ведь оба свойства существуют сами по себе

//in встречается редко в коде в таком виде

/*
цикл "for...in..." представляет собой for(;;) для ПЕРЕБОРА объектов
*/

//вывод все свойства объекта PC

let PC = {
    ramGB: 16,
    cpCores: 4,
    rgb: false,
    VC: "Asus",
};

for(let key in PC){
    console.log(key);
    console.log(PC[key]);
}
//или
for(let key in PC){    
    console.log(key + ":" + PC[key]);
}

//не обязательно называть переменную key можно было назвать её как угодно по правилам объявления переменных

/*
прикол for in в том что он по дефолту преобразует имена свойств по типу "1", "2"... в целочисленный, но не преобразует строки и флоты.
И что с этого?
а также он по дефолту сортирует в порядке возрастания все целочисленные имена свойств игнорируя порядок имён в объекте
сначала отсортированные числа потом всё остальное
*/

//допустим для немецкой аудитории мы хотим вывести варианты номера телефонов

let codes1 = {
    "49": "Германия",
    "41": "Швейцария",
    "44": "Великобритания",
    // ..,
    "1": "США",
    
};

for (let code in codes1) {
    console.log(code);//1 41 44 49
}
//но как мы видим сначала вывордиться американский номер, что нам не нужно
console.log("------------")

//чтобы этого избежать, нам нужно просто привести числа к строкам

let codes2 = {
    "+49": "Германия",
    "+41": "Швейцария",
    "+44": "Великобритания",
    // ..,
    "+1": "США",
    
};

for (let code in codes2) {
    console.log(+code);//49 41 44 1
}

/* Итого

Объекты – это ассоциативные массивы с рядом дополнительных возможностей.

Они хранят свойства (пары ключ-значение), где:

    Ключи свойств должны быть строками или символами (обычно строками).
    Значения могут быть любого типа.

Чтобы получить доступ к свойству, мы можем использовать:

    Запись через точку: obj.property.
    Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].

Дополнительные операторы:

    Удаление свойства: delete obj.prop.
    Проверка существования свойства: "key" in obj.
    Перебор свойств объекта: цикл for for (let key in obj).

То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.

В JavaScript есть много других типов объектов:

    Array для хранения упорядоченных коллекций данных,
    Date для хранения информации о дате и времени,
    Error для хранения информации об ошибке.
    … и так далее.

У них есть свои особенности, которые мы изучим позже. Иногда люди говорят что-то вроде «тип данных Array» или «тип данных Date», но формально они не являются отдельными типами, а относятся к типу данных Object. Они лишь расширяют его различными способами.

Объекты в JavaScript очень мощные. Здесь мы только немного углубились в действительно огромную тему. Мы будем плотно работать с объектами и узнаем о них больше в следующих частях учебника.
 */