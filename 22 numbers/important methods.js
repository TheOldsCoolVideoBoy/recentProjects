//parseInt и parseFloat

/*
при преобразовании к числу мы пользовались унарным плюсом + или Number(). Если строка при приобразовании не являлась в точности числом, то результат был NaN.
*/

console.log(+"100px"); //NaN
console.log(Number("180cm")); //NaN

//единственное исключение - пробелы. они игнорируются

/*
Бывает что нам нужно привести значение с единицей измерения:
"19€"
"100px"
"12pt"
Для того чтобы получить значение из таких строк существует метод parseInt и parseFloat
*/
console.log(parseInt("100px"));// 100
console.log(parseFloat("12.5em"));// 12.5

console.log(parseInt("12.3"));//12 только значение до точки
console.log(parseFloat("12.3.4"));//12.3 значение до первой точки

//Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:

console.log(parseInt("a123"));// NaN, на первом символе происходит остановка чтения

/* Второй аргумент parseInt(str, radix)

Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:
 */
console.log( parseInt('0xff', 16) ); // 255
console.log( parseInt('ff', 16) ); // 255, без 0x тоже работает

console.log( parseInt('2n9c', 36) ); // 123456



//Проверка: isFinite и isNaN

/*
Infinity, -Infinity и NaN являются типом number но являютсяя "особенными", поэтому существуют отдельные функции для их проверки: 
*/

/* isNaN(value) преобразует значение в число и проверяет является ли оно NaN: */

console.log( isNaN(NaN) ); // true
console.log( isNaN("str") ); // true

// !!! функция NaN нужна потому что NaN === NaN не является с логической точки зрения сравнением (мы сравниваем всё что угодно со всем чем угодно)

console.log(NaN === NaN); // false

/* 
isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:
 */

console.log( isFinite("15") ); // true
console.log( isFinite("str") ); // false, потому что специальное значение: NaN
console.log( isFinite(Infinity) ); // false, потому что  специальное значение: Infinity

/*
Также isFinite используется для проверки, является ли строка числом:
*/

let num = +"123";

// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
console.log(isFinite(num));

//Помните, что пустая строка интерпретируется как 0 во всех числовых функциях, включая isFinite.



/* Number.isNaN и ]

Методы Number.isNaN и Number.isFinite – это более «строгие» версии функций isNaN и isFinite. Они не преобразуют аргумент в число, а наоборот – первым делом проверяют, является ли аргумент числом (принадлежит ли он к типу number).

    Number.isNaN(value) возвращает true только в том случае, если аргумент принадлежит к типу number и является NaN. Во всех остальных случаях возвращает false. */

alert( Number.isNaN(NaN) ); // true
alert( Number.isNaN("str" / 2) ); // true

// Обратите внимание на разный результат:
alert( Number.isNaN("str") ); // false, так как "str" является строкой, а не числом
alert( isNaN("str") ); // true, так как isNaN сначала преобразует строку "str" в число и в результате преобразования получает NaN

/* Number.isFinite(value) возвращает true только в том случае, если аргумент принадлежит к типу number и не является NaN/Infinity/-Infinity. Во всех остальных случаях возвращает false.
 */
    console.log( Number.isFinite(123) ); // true
    console.log( Number.isFinite(Infinity) ); // false
    console.log( Number.isFinite(2 / 0) ); // false

    // Обратите внимание на разный результат:
    console.log( Number.isFinite("123") ); // false, так как "123" является строкой, а не числом
    console.log( isFinite("123") ); // true, так как isFinite сначала преобразует строку "123" в число 123

/* Не стоит считать Number.isNaN и Number.isFinite более «корректными» версиями функций isNaN и isFinite. Это дополняющие друг-друга инструменты для разных задач. */




/* Сравнение Object.is

Существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:

    Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
    Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.

Во всех других случаях Object.is(a, b) идентичен a === b.

Этот способ сравнения часто используется в спецификации JavaScript. Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет точного совпадения, он использует Object.is (Определение SameValue).
 */



//Number.prototype.toFixed()

//Метод toFixed() форматирует число, используя запись с фиксированной запятой.

/* Синтаксис

numObj.toFixed([digits])

Параметры

digits

    Необязательный параметр. Количество цифр после десятичной запятой; может быть значением между 0 и 20 включительно, хотя реализации могут поддерживать и больший диапазон значений. Если аргумент опущен, он считается равным 0.

Возвращаемое значение

Строка, представляющая numObj, не использующая экспоненциальную запись и содержащая ровно digits цифр после десятичной запятой. Число округляется при необходимости, а дробная часть дополняется нулями таким образом, чтобы иметь указанную длину. Если numObj больше или равно 1e+21, этот метод просто вызывает метод Number.prototype.toString() и возвращает строку в экспоненциальной записи.
Выбрасываемые исключения

RangeError

    Если параметр digits слишком маленький или слишком большой. Значения между 0 и 20 включительно не будут порождать исключение RangeError. Также реализации могут поддерживать большие и меньшие значения.
TypeError

    Если этот метод вызывается на объекте, не являющимся объектом Number.

Пример: использование toFixed */

var numObj = 12345.6789;

numObj.toFixed();       // Вернёт '12346': обратите внимание на округление, дробной части нет
numObj.toFixed(1);      // Вернёт '12345.7': обратите внимание на округление
numObj.toFixed(6);      // Вернёт '12345.678900': обратите внимание на дополнение нулями
(1.23e+20).toFixed(2);  // Вернёт '123000000000000000000.00'
(1.23e-10).toFixed(2);  // Вернёт '0.00'
2.34.toFixed(1);        // Вернёт '2.3'
-2.34.toFixed(1);       // Вернёт -2.3 (в соответствии с приоритетом операций,
                        // отрицательные числовые литералы не возвращают строку...)
(-2.34).toFixed(1);     // Вернёт '-2.3' (...до тех пор, пока вы не заключите их в круглые скобки)



/* Округление */

/* В JavaScript есть несколько встроенных функций для работы с округлением:

Math.floor
    Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
Math.ceil
    Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
Math.round
    Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
Math.trunc (не поддерживается в Internet Explorer)
    Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.

Ниже представлена таблица с различиями между функциями округления:
        Math.floor 	Math.ceil 	Math.round 	Math.trunc
3.1         3           4       	3 	         3
3.6         3 	        4 	        4 	         3
-1.1 	   -2          -1 	       -1       	-1
-1.6       -2 	       -1 	       -2  	        -1

*/

/*
Допустим нам нужно округлить число 1.2345 до 2-х знаков после запятой, у нас несколько способов это сделать:
*/

/* Умножить и разделить.

Например, чтобы округлить число до второго знака после запятой, мы можем умножить число на 100, вызвать функцию округления и разделить обратно.
 */
let num1 = 1.2345;

console.log( Math.floor(num * 100) / 100 ); // 1.2345 -> 123.45 -> 123 -> 1.23

/* Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.
 */
let num2 = 1.2345;
console.log( num.toFixed(2) ); // "1.23"

/* Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу Math.round: */

let num3 = 12.36;
console.log( num.toFixed(1) ); // "12.4"

/* Обратите внимание, что результатом toFixed является строка. Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:
 */
let num4 = 12.34;
console.log( num.toFixed(5) ); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой

/* Мы можем преобразовать полученное значение в число, используя унарный оператор + или Number(), пример с унарным оператором: +num.toFixed(5). */