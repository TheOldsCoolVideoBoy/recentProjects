/*
при создании двух объектов с одной и той же переменной, например:
*/
let user = { Name : "John"};

let admin = user;

console.log(`admin name is ${admin.Name}`);
console.log(`user name is ${user.Name}`);
/*
Оба объекта имеют не две отдельные переменные, а ссылки на неё.
Что будет если изменить переменную в одном из объектов?
*/
admin.Name = "Pete";
console.log("only name of admin has changed")
console.log(`admin name is ${admin.Name}`);
console.log(`user name is ${user.Name}`);

/*
в обоих объектах переменная измениться, так как  по сути переменная независима.
объекты хранят лишь ссылку на эту переменную.
*/

/*
при сравнении объектов с одинаковыми переменными они будут равны(== и ===).
Но при сравнении пустых объектов они будут не равны.
*/

/* 
Клонирование и объединение, Object.assign

Итак, копирование объектной переменной создаёт ещё одну ссылку на тот же объект.
Но что, если нам всё же нужно дублировать объект? Создать независимую копию, клон?
Это тоже выполнимо, но немного сложнее, потому что в JavaScript для этого нет встроенного метода. Но на самом деле в этом редко возникает необходимость, копирования по ссылке в большинстве случаев вполне хватает.
Но если мы действительно этого хотим, то нам нужно создать новый объект и воспроизвести структуру существующего, перебрав его свойства и скопировав их на примитивном уровне.

Например так: */

let clone = {}; // новый пустой объект
user.Name = "John";
// давайте скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}

// теперь clone это полностью независимый объект с тем же содержимым
clone.name = "Pete"; // изменим в нём данные

console.log( user.Name ); // все ещё John в первоначальном объекте

/* Также мы можем использовать для этого метод Object.assign.

Синтаксис:

Object.assign(dest, [src1, src2, src3...])

    Первый аргумент dest — целевой объект.
    Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
    Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
    Возвращает объект dest.

Например, мы можем использовать его для объединения нескольких объектов в один:
 */

let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);

// теперь user = { name: "John", canView: true, canEdit: true }

/* Если скопированное имя свойства уже существует, оно будет перезаписано: */

let user = { name: "John" };

Object.assign(user, { name: "Pete" });

alert(user.name); // теперь user = { name: "Pete" }

/* Мы также можем использовать Object.assign для замены цикла for..in для простого клонирования: */

let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);

/* Он копирует все свойства user в пустой объект и возвращает его.
Также существуют и другие методы клонирования объекта. Например, с использованием оператора расширения clone = {...user}, рассмотренного далее */

/* Вложенное клонирование

До сих пор мы предполагали, что все свойства user примитивныe. Но свойства могут быть и ссылками на другие объекты. Что с ними делать?
Например, есть объект: */

let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182

/* Теперь недостаточно просто скопировать clone.sizes = user.sizes, потому что user.sizes – это объект, он будет скопирован по ссылке. Таким образом, clone и user будут иметь общий объект sizes:
 */
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, тот же объект

// user и clone обладают общим свойством sizes
user.sizes.width++;       // изменяем свойства в первом объекте
alert(clone.sizes.width); // 51, видим результат в другом

/* Чтобы исправить это, мы должны использовать цикл клонирования, который проверяет каждое значение user[key] и, если это объект, тогда также копирует его структуру. Это называется «глубоким клонированием». */

/* Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед заново, возьмите готовую реализацию, например _.cloneDeep(obj) из библиотеки JavaScript lodash.
Объекты, объявленные как константа, могут быть изменены

Важным побочным эффектом хранения объектов в качестве ссылок является то, что объект, объявленный как const, может быть изменён.

Например: */

const user = {
  name: "John"
};

user.name = "Pete"; // (*)

alert(user.name); // Pete

/* Может показаться, что строка (*) вызовет ошибку, но, это не так. Значение user это константа, оно всегда должно ссылаться на один и тот же объект, но свойства этого объекта могут свободно изменяться.

Другими словами, const user выдаст ошибку только в том случае, если мы попытаемся задать user=... в целом.

Тем не менее, если нам действительно нужно создать постоянные свойства объекта, это тоже возможно, но с использованием совершенно других методов. Мы затронем это в главе Флаги и дескрипторы свойств.

Итого

Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта», а «ссылку» (адрес в памяти) на это значение. Таким образом, копирование такой переменной или передача её в качестве аргумента функции копирует эту ссылку, а не сам объект.

Все операции с использованием скопированных ссылок (например, добавление/удаление свойств) выполняются с одним и тем же объектом.

Чтобы создать «реальную копию» (клон), мы можем использовать Object.assign для так называемой «поверхностной копии» (вложенные объекты копируются по ссылке) или функцию «глубокого клонирования», такую как _.cloneDeep(obj). */