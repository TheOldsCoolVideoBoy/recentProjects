/* Термины: «унарный», «бинарный», «операнд»

Прежде, чем мы двинемся дальше, давайте разберёмся с терминологией.

    Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».

    Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный:
 */
let var1 = 1;
var1 = -var1;
console.log( var1 ); // -1, применили унарный минус

//Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:

let var2 = 1, var3 = 3;
console.log( var3 - var2 ); // 2, бинарный минус вычитает значения

/* Формально, в последних примерах мы говорим о двух разных операторах, использующих один символ: оператор отрицания (унарный оператор, который обращает знак) и оператор вычитания (бинарный оператор, который вычитает одно число из другого). */

/* Математика

Поддерживаются следующие математические операторы:

    Сложение +,
    Вычитание -,
    Умножение *,
    Деление /,
    Взятие остатка от деления %,
    Возведение в степень **.

Первые четыре оператора очевидны, а про % и ** стоит сказать несколько слов. */

/* Взятие остатка %

Оператор взятия остатка %, несмотря на обозначение, никакого отношения к процентам не имеет.

Результат a % b – это остаток от целочисленного деления a на b.

Например: */
console.log( 5 % 2 ); // 1, остаток от деления 5 на 2
console.log( 8 % 3 ); // 2, остаток от деления 8 на 3


/* Возведение в степень **

В выражении a ** b оператор возведения в степень умножает a на само себя b раз.
Например: */

console.log( 2 ** 2 ); // 4  (2 умножено на себя 2 раза)
console.log( 2 ** 3 ); // 8  (2 * 2 * 2, 3 раза)
console.log( 2 ** 4 ); // 16 (2 * 2 * 2 * 2, 4 раза)

//Математически, оператор работает и для нецелых чисел. Например, квадратный корень является возведением в степень 1/2:
console.log( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)
console.log( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию кубического корня)


//Сложение строк при помощи бинарного +

/* Давайте рассмотрим специальные возможности операторов JavaScript, которые выходят за рамки школьной арифметики.
Обычно при помощи плюса '+' складывают числа.
Но если бинарный оператор '+' применить к строкам, то он их объединяет в одну: */
let var4 = "моя" + "строка";
console.log(var4); // моястрока

/* Обратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку.
Например: */
console.log( '1' + 2 ); // "12"
console.log( 2 + '1' ); // "21"

/* Как видите, не важно, первый или второй операнд является строкой.
Вот пример посложнее: */
console.log(2 + 2 + '1' ); // будет "41", а не "221"

/* Здесь операторы работают один за другим. Первый + складывает два числа и возвращает 4, затем следующий + объединяет результат со строкой, производя действие 4 + '1' = '41'.

Сложение и преобразование строк — это особенность бинарного плюса +. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.

Например, вычитание и деление: */
console.log( 6 - '2' ); // 4, '2' приводится к числу
console.log( '6' / '2' ); // 3, оба операнда приводятся к числам


//Приведение к числу, унарный +

/* Плюс + существует в двух формах: бинарной, которую мы использовали выше, и унарной.
Унарный, то есть применённый к одному значению, плюс + ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.
Например: */
// Не влияет на числа
let var5 = 1;
console.log( +var5 ); // 1

let var6 = -2;
console.log( +var6 ); // -2

// Преобразует не числа в числа
console.log( +true ); // 1
console.log( +"" );   // 0

/* На самом деле это то же самое, что и Number(...), только короче.
Необходимость преобразовывать строки в числа возникает очень часто. Например, обычно значения полей HTML-формы — это строки. А что, если их нужно, к примеру, сложить? */

/* Бинарный плюс сложит их как строки: */
let apples = "2";
let oranges = "3";
console.log( apples + oranges ); // "23", так как бинарный плюс объединяет строки

/* Поэтому используем унарный плюс, чтобы преобразовать к числу: */
let apples1 = "2";
let oranges1 = "3";

// оба операнда предварительно преобразованы в числа
console.log( +apples + +oranges ); // 5

// более длинный вариант
// console.log( Number(apples) + Number(oranges) ); // 5

/* С точки зрения математика, такое изобилие плюсов выглядит странным. Но с точки зрения программиста тут нет ничего особенного: сначала выполнятся унарные плюсы, которые приведут строки к числам, а затем бинарный '+' их сложит.

Почему унарные плюсы выполнились до бинарного сложения? Как мы сейчас увидим, дело в их приоритете. */


//Приоритет операторов

/* В том случае, если в выражении есть несколько операторов – порядок их выполнения определяется приоритетом, или, другими словами, существует определённый порядок выполнения операторов.

Из школы мы знаем, что умножение в выражении 1 + 2 * 2 выполнится раньше сложения. Это как раз и есть «приоритет». Говорят, что умножение имеет более высокий приоритет, чем сложение.

Скобки важнее, чем приоритет, так что, если мы не удовлетворены порядком по умолчанию, мы можем использовать их, чтобы изменить приоритет. Например, написать (1 + 2) * 2.

В JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше, – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.

Отрывок из таблицы приоритетов (нет необходимости всё запоминать, обратите внимание, что приоритет унарных операторов выше, чем соответствующих бинарных):
Приоритет 	Название 	        Обозначение
… 	           …                    …
15      унарный плюс                +
15     	унарный минус               -
14      возведение в степень        **
13      умножение                   *
13      деление 	                /
12      сложение                    +
12      вычитание                   -
…       …                           …
2       присваивание                =
…       …                           …

Так как «унарный плюс» имеет приоритет 15, который выше, чем 12 у «сложения» (бинарный плюс), то в выражении "+apples + +oranges" сначала выполнятся унарные плюсы, а затем сложение. */


//Присваивание

/* Давайте отметим, что в таблице приоритетов также есть оператор присваивания =. У него один из самых низких приоритетов: 2.

Именно поэтому, когда переменной что-либо присваивают, например, x = 2 * 2 + 1, то сначала выполнится арифметика, а уже затем произойдёт присваивание = с сохранением результата в x. */
let var7 = 2 * 2 + 1;
console.log( var7 ); // 5


//Присваивание = возвращает значение

/* Тот факт, что = является оператором, а не «магической» конструкцией языка, имеет интересные последствия.
Большинство операторов в JavaScript возвращают значение. Для некоторых это очевидно, например сложение + или умножение *. Но и оператор присваивания не является исключением.
Вызов x = value записывает value в x и возвращает его.
Благодаря этому присваивание можно использовать как часть более сложного выражения:
 */
let var8 = 1;
let var9 = 2;

let var10 = 3 - (var8 = var9 + 1);

console.log( var8 ); // 3
console.log( var10 ); // 0

/* В примере выше результатом (a = b + 1) будет значение, которое присваивается переменной a (то есть 3). Потом оно используется для дальнейших вычислений.
Забавное применение присваивания, не так ли? Нам нужно понимать, как это работает, потому что иногда это можно увидеть в JavaScript-библиотеках.
Однако писать самим в таком стиле не рекомендуется. Такие трюки не сделают ваш код более понятным или читабельным. */


//Присваивание по цепочке
//Рассмотрим ещё одну интересную возможность: цепочку присваиваний.
let var11, var12, var13;
var11 = var12 = var13 = 2 + 2;

console.log( var11 ); // 4
console.log( var12 ); // 4
console.log( var13 ); // 4

/* Такое присваивание работает справа налево. Сначала вычисляется самое правое выражение 2 + 2, и затем результат присваивается переменным слева: c, b и a. В конце у всех переменных будет одно значение.
Опять-таки, чтобы код читался легче, лучше разделять подобные конструкции на несколько строчек:
 */
var13 = 2 + 2;
var12 = var13;
var11 = var13;

/* Польза от такого стиля особенно ощущается при быстром просмотре кода. */

//Сокращённая арифметика с присваиванием

/* Часто нужно применить оператор к переменной и сохранить результат в ней же.
Например: */
let var14 = 2;
var14 = var14 + 5;
var14 = var14 * 2;

//Эту запись можно укоротить при помощи совмещённых операторов += и *=:
let var15 = 2;
var15 += 5; // теперь n = 7 (работает как n = n + 5)
var15 *= 2; // теперь n = 14 (работает как n = n * 2)

console.log( var15 ); // 14

/* Подобные краткие формы записи существуют для всех арифметических и побитовых операторов: /=, -= и так далее.

Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций: */
let var16 = 2;

var16 *= 3 + 5;

console.log( var16 ); // 16  (сначала выполнится правая часть, выражение идентично n *= 8)


//Сокращённая арифметика с присваиванием

/* Часто нужно применить оператор к переменной и сохранить результат в ней же.
Например: */
let var17 = 2;
var17 = var17 + 5;
var17 = var17 * 2;

//Эту запись можно укоротить при помощи совмещённых операторов += и *=:
let var18 = 2;
var18 += 5; // теперь n = 7 (работает как n = n + 5)
var18 *= 2; // теперь n = 14 (работает как n = n * 2)

console.log( var18 ); // 14

/* Подобные краткие формы записи существуют для всех арифметических и побитовых операторов: /=, -= и так далее.

Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание , то есть выполнится после большинства других операций:*/
let var19 = 2;

var19 *= 3 + 5;

console.log( var19 ); // 16  (сначала выполнится правая часть, выражение идентично n *= 8)\


//Побитовые операторы

/* Побитовые операторы работают с 32-разрядными целыми числами (при необходимости приводят к ним), на уровне их внутреннего двоичного представления.
Эти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования.
Поддерживаются следующие побитовые операторы:

    AND(и) ( & )
    OR(или) ( | )
    XOR(побитовое исключающее или) ( ^ )
    NOT(не) ( ~ )
    LEFT SHIFT(левый сдвиг) ( << )
    RIGHT SHIFT(правый сдвиг) ( >> )
    ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )

Они используются редко, когда возникает необходимость оперировать с числами на очень низком (побитовом) уровне. В ближайшем времени они нам не понадобятся, так как веб-разработчики редко к ним прибегают, хотя в некоторых сферах (например, в криптографии) они полезны. Можете прочитать раздел о них на MDN, когда возникнет реальная необходимость.
Оператор «запятая»

Оператор «запятая» (,) редко применяется и является одним из самых необычных. Иногда он используется для написания более короткого кода, поэтому нам нужно знать его, чтобы понимать, что при этом происходит.

Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, но возвращается результат только последнего.

Например: */
let var20 = (1 + 2, 3 + 4);
console.log( var20 ); // 7 (результат вычисления 3 + 4)

/* Первое выражение 1 + 2 выполняется, а результат отбрасывается. Затем идёт 3 + 4, выражение выполняется и возвращается результат.
Запятая имеет очень низкий приоритет

Пожалуйста, обратите внимание, что оператор , имеет очень низкий приоритет, ниже =, поэтому скобки важны в приведённом выше примере.

Без них в a = 1 + 2, 3 + 4 сначала выполнится +, суммируя числа в a = 3, 7, затем оператор присваивания = присвоит a = 3, а то, что идёт дальше, будет игнорировано. Всё так же, как в (a = 1 + 2), 3 + 4.

Зачем нам оператор, который отбрасывает всё, кроме последнего выражения?

Иногда его используют в составе более сложных конструкций, чтобы сделать несколько действий в одной строке.

Например: */

/* три операции в одной строке
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}

Такие трюки используются во многих JavaScript-фреймворках. Вот почему мы упоминаем их. Но обычно они не улучшают читабельность кода, поэтому стоит хорошо подумать, прежде чем их использовать. */

