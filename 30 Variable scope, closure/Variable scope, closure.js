/*Просто глава о области видимости в интерпретаторе... ничего интересного, но пара примеров есть
 */

/* Пара вопросов

Для начала давайте рассмотрим две ситуации, а затем изучим внутренние механизмы шаг за шагом, чтобы вы смогли ответить на эти и более сложные вопросы в будущем.

    Функция sayHi использует внешнюю переменную name. Какое значение будет использовать функция при выполнении?
 */
let name = "John";

function sayHi() {
  console.log("Hi, " + name);
}

name = "Pete";

sayHi(); // что будет показано: "John" или "Pete"?

/* Такие ситуации распространены и в браузерной и в серверной разработке. Выполнение функции может быть запланировано позже, чем она была создана, например, после какого-нибудь пользовательского действия или сетевого запроса.

Итак, вопрос в том, получит ли она доступ к последним изменениям?

Функция makeWorker создаёт другую функцию и возвращает её. Новая функция может быть вызвана откуда-то ещё. Получит ли она доступ к внешним переменным из места своего создания или места выполнения или из обоих?
 */
function makeWorker() {
  let name1 = "Pete";

  return function() {
    console.log(name1);
  };
}

let name1 = "John";

// create a function
let work = makeWorker();

// call it
work(); // что будет показано? "Pete" (из места создания) или "John" (из места выполнения)

/*
Как мы можежем видеть симмволы "{ }" ограничивают область видимости переменных. функция всегда сначала проверяет свою область видимости, и если ничего не находит, то обращается к области внешнее от своей, вплоть до глобальной.
*/


/*
Также интересено поведение независимо вызываемых вложенных функций
*/

function makeCounter() {
    let count = 0;
    return function() {
      return count++;
    };
  }
  
  let counter1 = makeCounter();
  let counter2 = makeCounter();
  
  console.log( counter1() ); // 0
  console.log( counter1() ); // 1
  
  console.log( counter2() ); // 0 (независимо)
  console.log( counter2() ); // 1 
  console.log( counter2() ); // 2

  console.log( counter1() ); // 2