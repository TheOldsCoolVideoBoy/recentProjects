/* Объявление

Существует два варианта синтаксиса для создания пустого массива:
 */
let arr = new Array();
let arr = [];

/* Практически всегда используется второй вариант синтаксиса. В скобках мы можем указать начальные значения элементов:
 */
let fruits = ["Яблоко", "Апельсин", "Слива"];

/* Элементы массива нумеруются, начиная с нуля.

Мы можем получить элемент, указав его номер в квадратных скобках: */

let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits[0] ); // Яблоко
alert( fruits[1] ); // Апельсин
alert( fruits[2] ); // Слива

/* Мы можем заменить элемент: */

fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]

/* …Или добавить новый к существующему массиву:
 */
fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]

/* Общее число элементов массива содержится в его свойстве length:
 */
let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits.length ); // 3

/* Вывести массив целиком можно при помощи alert.
 */
let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits ); // Яблоко, Апельсин, Слива

/* В массиве могут храниться элементы любого типа.

Например: */

// разные типы значений
let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];

// получить элемент с индексом 1 (объект) и затем показать его свойство
alert( arr[1].name ); // Джон

// получить элемент с индексом 3 (функция) и выполнить её
arr[3](); // привет

/* Висячая запятая

Список элементов массива, как и список свойств объекта, может оканчиваться запятой:

let fruits = [
  "Яблоко",
  "Апельсин",
  "Слива",
]; */

/* «Висячая запятая» упрощает процесс добавления/удаления элементов, так как все строки становятся идентичными. */


/* Получение последних элементов при помощи «at»
Новая возможность
Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил.

Допустим, нам нужен последний элемент массива.

Некоторые языки программирования позволяют использовать отрицательные индексы для той же цели, как-то так: fruits[-1].

Однако, в JavaScript такая запись не сработает. Её результатом будет undefined, поскольку индекс в квадратных скобках понимается буквально.

Мы можем явно вычислить индекс последнего элемента, а затем получить к нему доступ вот так: fruits[fruits.length - 1]. */

let fruits = ["Apple", "Orange", "Plum"];
alert( fruits[fruits.length-1] ); // Plum

/* Немного громоздко, не так ли? Нам нужно дважды написать имя переменной.

К счастью, есть более короткий синтаксис: fruits.at (-1): */

let fruits = ["Apple", "Orange", "Plum"];
// то же самое, что и fruits[fruits.length-1]
alert( fruits.at(-1) ); // Plum

/* Другими словами, arr.at(i):

    это ровно то же самое, что и arr[i], если i >= 0.
    для отрицательных значений i, он отступает от конца массива. */



/* Методы pop/push, shift/unshift */

/* push добавляет элемент в конец.
shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.
 */

/* Существует и другой вариант применения для массивов – структура данных, называемая стек.

Она поддерживает два вида операций:

    push добавляет элемент в конец.
    pop удаляет последний элемент. */



    /* Методы, работающие с концом массива:

    pop
    
        Удаляет последний элемент из массива и возвращает его:
     */
        let fruits = ["Яблоко", "Апельсин", "Груша"];
    
        alert( fruits.pop() ); // удаляем "Груша" и выводим его
    
        alert( fruits ); // Яблоко, Апельсин
    
/*         И fruits.pop() и fruits.at(-1) возвращают последний элемент массива, но fruits.pop() также изменяет массив, удаляя его.
    push */
    
/*         Добавляет элемент в конец массива: */
    
        let fruits = ["Яблоко", "Апельсин"];
    
        fruits.push("Груша");
    
        alert( fruits ); // Яблоко, Апельсин, Груша
    
/*         Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....
    
    Методы, работающие с началом массива:
    
    shift
    
        Удаляет из массива первый элемент и возвращает его: */
    
        let fruits = ["Яблоко", "Апельсин", "Груша"];
    
        alert( fruits.shift() ); // удаляем Яблоко и выводим его
    
        alert( fruits ); // Апельсин, Груша
    
/*     unshift
    
        Добавляет элемент в начало массива: */
    
        let fruits = ["Апельсин", "Груша"];
    
        fruits.unshift('Яблоко');
    
        alert( fruits ); // Яблоко, Апельсин, Груша
    
/*     Методы push и unshift могут добавлять сразу несколько элементов: */
    
    let fruits = ["Яблоко"];
    
    fruits.push("Апельсин", "Груша");
    fruits.unshift("Ананас", "Лимон");
    
    // ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
    alert( fruits );


/*     Итого

Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.

Объявление:

// квадратные скобки (обычно)
let arr = [item1, item2...];

// new Array (очень редко)
let arr = new Array(item1, item2...);

Вызов new Array(number) создаёт массив с заданной длиной, но без элементов.

    Свойство length отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется автоматически методами массива.
    Если мы уменьшаем length вручную, массив укорачивается.

Получение элементов:

    Мы можем получить элемент по его индексу, например arr[0].
    Также мы можем использовать метод at(i) для получения элементов с отрицательным индексом, для отрицательных значений i, он отступает от конца массива. В остальном он работает так же, как arr[i], если i >= 0.

Мы можем использовать массив как двустороннюю очередь, используя следующие операции:

    push(...items)добавляет items в конец массива.
    pop() удаляет элемент в конце массива и возвращает его.
    shift() удаляет элемент в начале массива и возвращает его.
    unshift(...items) добавляет items в начало массива.

Чтобы пройтись по элементам массива:

    for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
    for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).
    for (let i in arr) – никогда не используйте для массивов!

Мы вернёмся к массивам и изучим другие методы добавления, удаления, выделения элементов и сортировки массивов в главе: Методы массивов. */